# 디자인 패턴 개요

> **핵심 한줄 요약**: 디자인 패턴은 소프트웨어 설계에서 반복적으로 나타나는 문제에 대한 검증된 해결 템플릿이다.

---

## 목차

1. [디자인 패턴이란?](#1-디자인-패턴이란)
2. [GoF (Gang of Four) 소개](#2-gof-gang-of-four-소개)
3. [패턴의 3가지 분류](#3-패턴의-3가지-분류)
4. [전체 패턴 한줄 요약 표](#4-전체-패턴-한줄-요약-표)
5. [언제 패턴을 사용해야 하는가?](#5-언제-패턴을-사용해야-하는가)
6. [안티패턴 경고](#6-안티패턴-경고)
7. [학습 순서 가이드](#7-학습-순서-가이드)
8. [정리 및 체크리스트](#8-정리-및-체크리스트)

---

## 1. 디자인 패턴이란?

### 정의

디자인 패턴(Design Pattern)은 소프트웨어 설계 과정에서 자주 발생하는 문제들에 대해 **재사용 가능한 해결책**을 정리한 것이다. 패턴은 특정 코드가 아니라 **문제 해결을 위한 청사진(blueprint)** 이다.

### 비유로 이해하기

건축에서 "아치형 출입구"라는 패턴이 있다고 하자. 이 패턴은 특정 건물의 설계도가 아니라, **아치형 구조를 적용할 수 있는 일반적인 원칙**이다. 재료(돌, 나무, 철)와 크기는 달라질 수 있지만, 핵심 구조는 동일하다. 소프트웨어 디자인 패턴도 마찬가지다.

### 패턴의 구성 요소

| 구성 요소 | 설명 |
|-----------|------|
| **패턴 이름(Name)** | 문제와 해결책을 간결하게 설명하는 이름 |
| **문제(Problem)** | 패턴이 해결하고자 하는 상황과 조건 |
| **해결책(Solution)** | 설계의 구성 요소, 관계, 책임을 서술 |
| **결과(Consequences)** | 패턴 적용의 장단점과 트레이드오프 |

### 패턴을 왜 배워야 하는가?

```
경력 2~3년차 개발자가 패턴을 배워야 하는 이유:

1. 코드 리뷰에서 "이건 Strategy 패턴으로 리팩토링하면 좋겠어요"
   → 팀 커뮤니케이션이 원활해진다

2. 프레임워크 소스를 읽을 때 패턴을 알면 구조가 보인다
   → Django의 Template Method, Spring의 Factory 등

3. 설계 의사결정의 근거를 명확히 할 수 있다
   → "왜 이렇게 설계했나요?" 에 대한 답변 가능

4. 유지보수하기 쉬운 코드를 작성하게 된다
   → 변경에 유연한 구조 설계
```

---

## 2. GoF (Gang of Four) 소개

### 누구인가?

1994년, 네 명의 저자가 **"Design Patterns: Elements of Reusable Object-Oriented Software"** 라는 책을 출간했다. 이 네 명을 **GoF(Gang of Four)** 라고 부른다.

| 이름 | 역할 |
|------|------|
| Erich Gamma | Eclipse JDT, JUnit 공동 개발자 |
| Richard Helm | 소프트웨어 아키텍트 |
| Ralph Johnson | 일리노이 대학 교수 |
| John Vlissides | IBM 연구원 |

### GoF 책의 의의

- 23개의 디자인 패턴을 체계적으로 정리
- 객체지향 설계의 **공통 어휘(vocabulary)** 를 확립
- "바퀴를 다시 발명하지 마라"는 원칙을 실현
- 30년이 지난 지금도 소프트웨어 설계의 기본서로 통용

### 주의: GoF 패턴이 전부는 아니다

GoF의 23개 패턴 이후에도 다양한 패턴이 등장했다:

- **Repository 패턴** (데이터 접근 추상화)
- **Unit of Work** (트랜잭션 관리)
- **CQRS** (명령과 조회의 분리)
- **Event Sourcing** (이벤트 기반 상태 관리)

GoF 패턴은 **기초 체력**이고, 이를 바탕으로 더 고급 패턴을 학습해 나가면 된다.

---

## 3. 패턴의 3가지 분류

GoF는 23개 패턴을 **목적(purpose)** 에 따라 세 가지로 분류했다.

```
┌─────────────────────────────────────────────────────┐
│                   디자인 패턴 (23개)                   │
├──────────────┬──────────────────┬────────────────────┤
│  생성 패턴     │   구조 패턴        │    행위 패턴        │
│ (Creational)  │  (Structural)    │  (Behavioral)     │
│   5개         │    7개            │     11개           │
├──────────────┼──────────────────┼────────────────────┤
│ 객체 생성      │ 클래스/객체 결합    │ 객체 간 상호작용     │
│ 메커니즘       │ 구조 설계         │  책임 분배          │
└──────────────┴──────────────────┴────────────────────┘
```

### 3.1 생성 패턴 (Creational Patterns) - 5개

**목적**: 객체를 어떻게 생성할 것인가?

객체 생성 과정을 추상화하여, 시스템이 어떤 구체 클래스를 사용하는지 감추고, 객체가 생성/구성/표현되는 방식에 유연성을 부여한다.

| 패턴 | 핵심 |
|------|------|
| Singleton | 인스턴스를 하나만 만든다 |
| Factory Method | 생성을 서브클래스에 맡긴다 |
| Abstract Factory | 관련 객체 가족을 통째로 만든다 |
| Builder | 복잡한 객체를 단계별로 조립한다 |
| Prototype | 기존 객체를 복제해서 만든다 |

### 3.2 구조 패턴 (Structural Patterns) - 7개

**목적**: 클래스와 객체를 어떻게 합성(compose)할 것인가?

더 큰 구조를 만들기 위해 클래스나 객체를 조합하는 방법을 다룬다.

| 패턴 | 핵심 |
|------|------|
| Adapter | 호환되지 않는 인터페이스를 연결한다 |
| Bridge | 추상화와 구현을 분리한다 |
| Composite | 트리 구조로 부분-전체 계층을 표현한다 |
| Decorator | 동적으로 책임(기능)을 추가한다 |
| Facade | 복잡한 서브시스템에 단순한 인터페이스를 제공한다 |
| Flyweight | 공유를 통해 많은 수의 세밀한 객체를 효율적으로 관리한다 |
| Proxy | 다른 객체에 대한 접근을 제어하는 대리자를 둔다 |

### 3.3 행위 패턴 (Behavioral Patterns) - 11개

**목적**: 객체들 사이의 책임 분배와 통신을 어떻게 할 것인가?

객체 간의 알고리즘과 책임 할당에 대한 패턴이다.

| 패턴 | 핵심 |
|------|------|
| Chain of Responsibility | 요청을 처리할 객체를 체인으로 연결한다 |
| Command | 요청을 객체로 캡슐화한다 |
| Interpreter | 언어의 문법을 정의하고 해석한다 |
| Iterator | 컬렉션 요소를 순차 접근한다 |
| Mediator | 객체 간 상호작용을 중재자가 관리한다 |
| Memento | 객체 상태를 저장하고 복원한다 |
| Observer | 상태 변경을 구독자에게 알린다 |
| State | 상태에 따라 행동을 변경한다 |
| Strategy | 알고리즘을 교체 가능하게 캡슐화한다 |
| Template Method | 알고리즘 골격을 정의하고 일부를 서브클래스에 위임한다 |
| Visitor | 객체 구조에 새로운 연산을 추가한다 |

---

## 4. 전체 패턴 한줄 요약 표

### 생성 패턴 (Creational)

| # | 패턴 | 한줄 요약 | 난이도 | 사용 빈도 |
|---|------|----------|--------|----------|
| 1 | Singleton | 클래스 인스턴스를 하나만 보장하고 전역 접근점 제공 | ★☆☆ | 높음 |
| 2 | Factory Method | 객체 생성을 서브클래스에 위임하여 유연성 확보 | ★★☆ | 높음 |
| 3 | Abstract Factory | 관련 객체 가족 전체를 일관되게 생성 | ★★★ | 중간 |
| 4 | Builder | 복잡한 객체를 단계별로 조립 | ★★☆ | 높음 |
| 5 | Prototype | 기존 객체를 복제하여 새 객체 생성 | ★☆☆ | 중간 |

### 구조 패턴 (Structural)

| # | 패턴 | 한줄 요약 | 난이도 | 사용 빈도 |
|---|------|----------|--------|----------|
| 6 | Adapter | 호환 안 되는 인터페이스를 변환하여 함께 동작하게 함 | ★★☆ | 높음 |
| 7 | Bridge | 추상화와 구현부를 분리하여 독립적 변화 가능 | ★★★ | 중간 |
| 8 | Composite | 개별 객체와 복합 객체를 동일하게 다룸 | ★★☆ | 중간 |
| 9 | Decorator | 런타임에 객체에 새로운 행동을 동적으로 추가 | ★★☆ | 높음 |
| 10 | Facade | 복잡한 서브시스템에 간단한 인터페이스 제공 | ★☆☆ | 높음 |
| 11 | Flyweight | 공유를 통해 대량의 세밀한 객체를 효율적 지원 | ★★★ | 낮음 |
| 12 | Proxy | 다른 객체로의 접근을 제어하는 대리자 제공 | ★★☆ | 중간 |

### 행위 패턴 (Behavioral)

| # | 패턴 | 한줄 요약 | 난이도 | 사용 빈도 |
|---|------|----------|--------|----------|
| 13 | Chain of Responsibility | 요청 처리 기회를 여러 객체에 부여 | ★★☆ | 중간 |
| 14 | Command | 요청 자체를 객체로 캡슐화하여 매개변수화 | ★★☆ | 높음 |
| 15 | Interpreter | 간단한 언어의 문법과 해석기 정의 | ★★★ | 낮음 |
| 16 | Iterator | 내부 표현을 노출하지 않고 순차 접근 | ★☆☆ | 높음 |
| 17 | Mediator | 객체들의 상호작용을 캡슐화하여 결합도 감소 | ★★☆ | 중간 |
| 18 | Memento | 캡슐화를 유지하면서 객체 상태를 저장/복원 | ★★☆ | 중간 |
| 19 | Observer | 객체 상태 변경 시 의존 객체들에게 자동 통지 | ★★☆ | 높음 |
| 20 | State | 내부 상태에 따라 객체 행동 변경 | ★★☆ | 중간 |
| 21 | Strategy | 알고리즘 군을 정의하고 교체 가능하게 캡슐화 | ★★☆ | 높음 |
| 22 | Template Method | 알고리즘 뼈대를 정의, 일부 단계를 서브클래스에 위임 | ★★☆ | 중간 |
| 23 | Visitor | 객체 구조의 원소에 수행할 연산을 별도 정의 | ★★★ | 낮음 |

---

## 5. 언제 패턴을 사용해야 하는가?

### 패턴을 적용해야 할 때

```
[패턴 사용 판단 플로우차트]

문제 발생
    │
    ▼
같은 문제를 반복적으로 겪고 있는가? ──No──→ 단순 해결
    │
   Yes
    │
    ▼
코드가 변경/확장에 취약한가? ──No──→ 현재 구조 유지
    │
   Yes
    │
    ▼
적합한 패턴이 존재하는가? ──No──→ 자체 설계 (SOLID 원칙 기반)
    │
   Yes
    │
    ▼
패턴 적용의 비용 < 이득인가? ──No──→ 과도한 설계 주의
    │
   Yes
    │
    ▼
패턴 적용!
```

### 구체적인 적용 시점

| 상황 | 적합한 패턴 |
|------|------------|
| 객체 생성 로직이 복잡하거나, 조건에 따라 다른 객체를 만들어야 할 때 | Factory Method, Abstract Factory |
| 생성자에 매개변수가 5개 이상일 때 | Builder |
| 전역적으로 하나의 인스턴스만 필요할 때 | Singleton |
| 기존 객체를 복사해서 약간만 수정해야 할 때 | Prototype |
| 외부 라이브러리의 인터페이스가 우리 코드와 맞지 않을 때 | Adapter |
| 객체에 동적으로 기능을 추가/제거해야 할 때 | Decorator |
| 여러 알고리즘 중 하나를 런타임에 선택해야 할 때 | Strategy |
| 상태에 따라 행동이 완전히 달라져야 할 때 | State |
| 이벤트 기반으로 여러 객체에 변경을 통지해야 할 때 | Observer |

### 패턴을 적용하지 말아야 할 때

1. **문제가 명확하지 않을 때**: 패턴은 해결책이지, 찾아서 적용할 문제가 아니다
2. **단순한 코드에 무리하게 적용할 때**: if문 하나면 해결될 일에 Strategy 패턴을 도입하지 마라
3. **"이 패턴을 써봐야지"라는 동기로 시작할 때**: 패턴은 목적이 아니라 수단이다
4. **팀원 대부분이 해당 패턴을 모를 때**: 이해할 수 없는 코드는 좋은 코드가 아니다

---

## 6. 안티패턴 경고

### 안티패턴이란?

자주 사용되지만 실제로는 **비효율적이거나 해로운** 설계 방식을 말한다.

### 대표적인 안티패턴

| 안티패턴 | 설명 | 올바른 접근 |
|---------|------|-----------|
| **Golden Hammer** | 익숙한 패턴 하나로 모든 문제를 해결하려 함 | 문제에 맞는 패턴 선택 |
| **Cargo Cult** | 이유 없이 패턴을 따라 씀 | "왜 이 패턴인가?" 항상 질문 |
| **God Object** | 하나의 클래스가 너무 많은 책임을 가짐 | SRP 원칙 적용 |
| **Spaghetti Code** | 구조 없이 얽힌 코드 | 패턴과 원칙 기반 리팩토링 |
| **Lava Flow** | 아무도 건드리지 않는 레거시 코드가 남아있음 | 테스트 작성 후 점진적 리팩토링 |
| **Premature Optimization** | 필요 없는 곳에 미리 최적화 | 측정 후 최적화 |

### 패턴 남용 경고 (Pattern Abuse)

```python
# 나쁜 예: 불필요한 팩토리 패턴
class GreetingFactory:
    def create_greeting(self, name):
        return f"Hello, {name}!"

# 좋은 예: 단순한 함수로 충분하다
def greet(name):
    return f"Hello, {name}!"
```

```csharp
// 나쁜 예: 불필요한 Strategy 패턴
public interface IAddStrategy
{
    int Add(int a, int b);
}
public class AddStrategy : IAddStrategy
{
    public int Add(int a, int b) => a + b;
}

// 좋은 예: 단순한 메서드로 충분하다
public static int Add(int a, int b) => a + b;
```

> **원칙**: 패턴을 적용하기 전에 "이 패턴 없이 더 간단하게 해결할 수 있는가?"를 먼저 자문하라.

---

## 7. 학습 순서 가이드

### 추천 학습 경로

경력 2~3년차 개발자를 위한 단계별 학습 순서이다.

```
Phase 1: 기초 (1~2주)
├── SOLID 원칙 복습
├── Singleton 패턴
├── Factory Method 패턴
└── Strategy 패턴

Phase 2: 핵심 (2~3주)
├── Observer 패턴
├── Decorator 패턴
├── Builder 패턴
├── Adapter 패턴
└── Template Method 패턴

Phase 3: 확장 (2~3주)
├── Abstract Factory 패턴
├── Command 패턴
├── State 패턴
├── Facade 패턴
├── Prototype 패턴
└── Composite 패턴

Phase 4: 고급 (필요할 때)
├── Proxy 패턴
├── Bridge 패턴
├── Flyweight 패턴
├── Chain of Responsibility 패턴
├── Mediator 패턴
├── Memento 패턴
├── Visitor 패턴
└── Interpreter 패턴
```

### 학습 방법 제안

1. **패턴의 의도(Intent)를 먼저 이해하라**: 구현보다 "왜"가 중요하다
2. **실무 코드에서 패턴을 찾아라**: 사용 중인 프레임워크에서 패턴을 식별해 보라
3. **직접 구현하라**: 읽는 것과 쓰는 것은 다르다
4. **리팩토링에 적용하라**: 새 코드보다 기존 코드 개선에 먼저 적용해 보라
5. **코드 리뷰에서 활용하라**: "이 부분은 X 패턴을 적용하면 어떨까요?"

### 실무에서 자주 쓰는 패턴 TOP 7

| 순위 | 패턴 | 실무 활용 예시 |
|------|------|--------------|
| 1 | Strategy | 결제 방식 선택, 정렬 알고리즘 교체 |
| 2 | Observer | 이벤트 시스템, 알림 발송 |
| 3 | Factory Method | 객체 생성 분기, DI 컨테이너 |
| 4 | Builder | HTTP 요청 구성, 쿼리 빌더 |
| 5 | Decorator | 미들웨어, 로깅, 인증 처리 |
| 6 | Adapter | 외부 API 연동, 레거시 통합 |
| 7 | Singleton | 설정 관리, 로깅, 커넥션 풀 |

---

## 8. 정리 및 체크리스트

### 핵심 정리

- 디자인 패턴은 **반복되는 설계 문제에 대한 검증된 해결 템플릿**이다
- GoF는 23개 패턴을 **생성(5), 구조(7), 행위(11)** 로 분류했다
- 패턴은 **목적이 아니라 수단**이다. 문제가 먼저이고, 패턴은 그 다음이다
- **과도한 패턴 적용**은 오히려 코드를 복잡하게 만든다

### 학습 체크리스트

- [ ] 디자인 패턴의 정의와 목적을 설명할 수 있다
- [ ] GoF의 23개 패턴을 3가지 범주로 분류할 수 있다
- [ ] 각 범주(생성, 구조, 행위)의 목적 차이를 설명할 수 있다
- [ ] 패턴을 적용해야 할 때와 적용하지 말아야 할 때를 구분할 수 있다
- [ ] 안티패턴의 개념을 이해하고, 대표적인 안티패턴을 3개 이상 설명할 수 있다
- [ ] 내가 사용하는 프레임워크에서 적용된 패턴을 3개 이상 식별할 수 있다

### 다음 학습

이 개요를 이해했다면, [생성 패턴](./01-creational/)부터 하나씩 학습해 보자.

---

## 관련 패턴 및 참고 자료

### 함께 읽으면 좋은 원칙

- **SOLID 원칙**: 디자인 패턴의 기반이 되는 객체지향 설계 원칙
- **DRY (Don't Repeat Yourself)**: 중복 제거 원칙
- **KISS (Keep It Simple, Stupid)**: 단순함을 유지하는 원칙
- **YAGNI (You Ain't Gonna Need It)**: 필요할 때 구현하는 원칙

### 참고 서적

- "Design Patterns: Elements of Reusable Object-Oriented Software" - GoF (1994)
- "Head First Design Patterns" - Freeman & Robson
- "Refactoring: Improving the Design of Existing Code" - Martin Fowler
- "Clean Architecture" - Robert C. Martin
